{"ast":null,"code":"import Node from \"./NodeClass\";\nexport default class AVLTree {\n  constructor() {\n    this.root = null;\n  }\n\n  height(node) {\n    return node === null ? -1 : node.height;\n  }\n\n  getNode(val) {\n    let current = this.root;\n\n    while (current) {\n      if (val === current.value) {\n        return current;\n      }\n\n      if (val < current.value) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n\n    return current;\n  }\n\n  insert(val) {\n    this.root = this.insertHelper(this.root, val);\n    tree.levelOrder();\n  }\n\n  insertHelper(node, val) {\n    if (node === null) return new Node(val);\n    if (val < node.value) node.left = this.insertHelper(node.left, val);else if (val > node.value) node.right = this.insertHelper(node.right, val);\n    return node;\n  }\n\n  levelOrder() {\n    if (!this.root) {\n      return;\n    }\n\n    let queues = [[], []];\n    let current_queue = queues[0];\n    let next_queue = queues[1];\n    current_queue.push(this.root);\n    let level_number = 0;\n    let currKey = 1;\n\n    while (current_queue.length > 0) {\n      let temp = current_queue.shift();\n      temp.key = currKey;\n      currKey += 1;\n\n      if (temp.left) {\n        next_queue.push(temp.left);\n      }\n\n      if (temp.right) {\n        next_queue.push(temp.right);\n      }\n\n      if (current_queue.length === 0) {\n        level_number++;\n        current_queue = queues[level_number % 2];\n        next_queue = queues[(level_number + 1) % 2];\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Muaath/Desktop/AVL/src/AVLTreeVisualizer/AVLTreeClass.js"],"names":["Node","AVLTree","constructor","root","height","node","getNode","val","current","value","left","right","insert","insertHelper","tree","levelOrder","queues","current_queue","next_queue","push","level_number","currKey","length","temp","shift","key"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,aAAjB;AAEA,eAAe,MAAMC,OAAN,CAAc;AACzBC,EAAAA,WAAW,GAAG;AACV,SAAKC,IAAL,GAAY,IAAZ;AACH;;AAEDC,EAAAA,MAAM,CAACC,IAAD,EAAO;AACT,WAAOA,IAAI,KAAK,IAAT,GAAgB,CAAC,CAAjB,GAAqBA,IAAI,CAACD,MAAjC;AACH;;AAEDE,EAAAA,OAAO,CAACC,GAAD,EAAM;AACT,QAAIC,OAAO,GAAG,KAAKL,IAAnB;;AACA,WAAOK,OAAP,EAAgB;AACZ,UAAID,GAAG,KAAKC,OAAO,CAACC,KAApB,EAA2B;AACvB,eAAOD,OAAP;AACH;;AACD,UAAID,GAAG,GAAGC,OAAO,CAACC,KAAlB,EAAyB;AACrBD,QAAAA,OAAO,GAAGA,OAAO,CAACE,IAAlB;AACH,OAFD,MAEO;AACHF,QAAAA,OAAO,GAAGA,OAAO,CAACG,KAAlB;AACH;AACJ;;AACD,WAAOH,OAAP;AACH;;AAEDI,EAAAA,MAAM,CAACL,GAAD,EAAM;AACR,SAAKJ,IAAL,GAAY,KAAKU,YAAL,CAAkB,KAAKV,IAAvB,EAA6BI,GAA7B,CAAZ;AACAO,IAAAA,IAAI,CAACC,UAAL;AACH;;AAEDF,EAAAA,YAAY,CAACR,IAAD,EAAOE,GAAP,EAAY;AACpB,QAAIF,IAAI,KAAK,IAAb,EAAmB,OAAO,IAAIL,IAAJ,CAASO,GAAT,CAAP;AAEnB,QAAIA,GAAG,GAAGF,IAAI,CAACI,KAAf,EAAsBJ,IAAI,CAACK,IAAL,GAAY,KAAKG,YAAL,CAAkBR,IAAI,CAACK,IAAvB,EAA6BH,GAA7B,CAAZ,CAAtB,KACK,IAAIA,GAAG,GAAGF,IAAI,CAACI,KAAf,EAAsBJ,IAAI,CAACM,KAAL,GAAa,KAAKE,YAAL,CAAkBR,IAAI,CAACM,KAAvB,EAA8BJ,GAA9B,CAAb;AAE3B,WAAOF,IAAP;AACH;;AAEDU,EAAAA,UAAU,GAAG;AACT,QAAI,CAAC,KAAKZ,IAAV,EAAgB;AACZ;AACH;;AAED,QAAIa,MAAM,GAAG,CACT,EADS,EAET,EAFS,CAAb;AAIA,QAAIC,aAAa,GAAGD,MAAM,CAAC,CAAD,CAA1B;AACA,QAAIE,UAAU,GAAGF,MAAM,CAAC,CAAD,CAAvB;AAEAC,IAAAA,aAAa,CAACE,IAAd,CAAmB,KAAKhB,IAAxB;AACA,QAAIiB,YAAY,GAAG,CAAnB;AAEA,QAAIC,OAAO,GAAG,CAAd;;AAEA,WAAOJ,aAAa,CAACK,MAAd,GAAuB,CAA9B,EAAiC;AAC7B,UAAIC,IAAI,GAAGN,aAAa,CAACO,KAAd,EAAX;AACAD,MAAAA,IAAI,CAACE,GAAL,GAAWJ,OAAX;AACAA,MAAAA,OAAO,IAAI,CAAX;;AACA,UAAIE,IAAI,CAACb,IAAT,EAAe;AACXQ,QAAAA,UAAU,CAACC,IAAX,CAAgBI,IAAI,CAACb,IAArB;AACH;;AAED,UAAIa,IAAI,CAACZ,KAAT,EAAgB;AACZO,QAAAA,UAAU,CAACC,IAAX,CAAgBI,IAAI,CAACZ,KAArB;AACH;;AAED,UAAIM,aAAa,CAACK,MAAd,KAAyB,CAA7B,EAAgC;AAC5BF,QAAAA,YAAY;AACZH,QAAAA,aAAa,GAAGD,MAAM,CAACI,YAAY,GAAG,CAAhB,CAAtB;AACAF,QAAAA,UAAU,GAAGF,MAAM,CAAC,CAACI,YAAY,GAAG,CAAhB,IAAqB,CAAtB,CAAnB;AACH;AACJ;AACJ;;AAzEwB","sourcesContent":["import Node from \"./NodeClass\"\r\n\r\nexport default class AVLTree {\r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n\r\n    height(node) {\r\n        return node === null ? -1 : node.height;\r\n    }\r\n\r\n    getNode(val) {\r\n        let current = this.root;\r\n        while (current) {\r\n            if (val === current.value) {\r\n                return current;\r\n            }\r\n            if (val < current.value) {\r\n                current = current.left;\r\n            } else {\r\n                current = current.right;\r\n            }\r\n        }\r\n        return current;\r\n    }\r\n\r\n    insert(val) {\r\n        this.root = this.insertHelper(this.root, val);\r\n        tree.levelOrder();\r\n    }\r\n\r\n    insertHelper(node, val) {\r\n        if (node === null) return new Node(val);\r\n\r\n        if (val < node.value) node.left = this.insertHelper(node.left, val);\r\n        else if (val > node.value) node.right = this.insertHelper(node.right, val);\r\n\r\n        return node;\r\n    }\r\n\r\n    levelOrder() {\r\n        if (!this.root) {\r\n            return;\r\n        }\r\n\r\n        let queues = [\r\n            [],\r\n            []\r\n        ];\r\n        let current_queue = queues[0];\r\n        let next_queue = queues[1];\r\n\r\n        current_queue.push(this.root);\r\n        let level_number = 0;\r\n\r\n        let currKey = 1;\r\n\r\n        while (current_queue.length > 0) {\r\n            let temp = current_queue.shift();\r\n            temp.key = currKey;\r\n            currKey += 1;\r\n            if (temp.left) {\r\n                next_queue.push(temp.left);\r\n            }\r\n\r\n            if (temp.right) {\r\n                next_queue.push(temp.right);\r\n            }\r\n\r\n            if (current_queue.length === 0) {\r\n                level_number++;\r\n                current_queue = queues[level_number % 2];\r\n                next_queue = queues[(level_number + 1) % 2];\r\n            }\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}