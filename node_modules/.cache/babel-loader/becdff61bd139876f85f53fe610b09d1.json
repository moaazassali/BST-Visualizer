{"ast":null,"code":"import Node from \"./NodeClass\";\nexport default class AVLTree {\n  constructor() {\n    this.root = null;\n    this.size = 0;\n  }\n\n  height(node) {\n    return node === null ? -1 : node.height;\n  }\n\n  calculateTreeHeight() {\n    this.root.height = this.calculateHeight(this.root);\n  }\n\n  calculateHeight(node) {\n    if (node === null) return -1;else {\n      let leftHeight = this.calculateHeight(node.left);\n      let rightHeight = this.calculateHeight(node.right);\n      return Math.max(leftHeight, rightHeight);\n    }\n  }\n\n  getNode(val) {\n    let current = this.root;\n\n    while (current) {\n      if (val === current.value) {\n        return current;\n      }\n\n      if (val < Number(current.value)) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n\n    return current;\n  }\n\n  insert(val) {\n    this.root = this.insertHelper(this.root, val);\n    this.setKey(val);\n    this.size += 1;\n    this.calculateTreeHeight();\n  }\n\n  insertHelper(node, val) {\n    if (node === null) return new Node(val);\n    if (val < node.value) node.left = this.insertHelper(node.left, val);else if (val > node.value) node.right = this.insertHelper(node.right, val);\n    return node;\n  }\n\n  delete(val) {\n    let node = this.getNode(val);\n    if (node.val > node.parent) node.parent.right = null;else node.parent.left = null;\n    node.parent = null;\n  }\n\n  setKey(val) {\n    let current = this.root;\n    let binaryArray = [1];\n\n    while (current) {\n      if (val === current.value) {\n        break;\n      }\n\n      if (val > current.value) {\n        current = current.right;\n        binaryArray.push(1);\n      } else {\n        current = current.left;\n        binaryArray.push(0);\n      }\n    }\n\n    const binaryString = binaryArray.join(\"\");\n    current.key = parseInt(binaryString, 2);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Muaath/Desktop/AVL/src/AVLTreeVisualizer/AVLTreeClass.js"],"names":["Node","AVLTree","constructor","root","size","height","node","calculateTreeHeight","calculateHeight","leftHeight","left","rightHeight","right","Math","max","getNode","val","current","value","Number","insert","insertHelper","setKey","delete","parent","binaryArray","push","binaryString","join","key","parseInt"],"mappings":"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","sourcesContent":["import Node from \"./NodeClass\"\r\n\r\nexport default class AVLTree {\r\n    constructor() {\r\n        this.root = null;\r\n        this.size = 0;\r\n    }\r\n\r\n    height(node) {\r\n        return node === null ? -1 : node.height;\r\n    }\r\n\r\n    calculateTreeHeight() {\r\n        this.root.height = this.calculateHeight(this.root);\r\n    }\r\n\r\n    calculateHeight(node) {\r\n        if (node === null) return -1;\r\n        else {\r\n            let leftHeight = this.calculateHeight(node.left);\r\n            let rightHeight = this.calculateHeight(node.right);\r\n            return Math.max(leftHeight, rightHeight);\r\n        }\r\n    }\r\n\r\n    getNode(val) {\r\n        let current = this.root;\r\n        while (current) {\r\n            if (val === current.value) {\r\n                return current;\r\n            }\r\n            if (val < Number(current.value)) {\r\n                current = current.left;\r\n            } else {\r\n                current = current.right;\r\n            }\r\n        }\r\n        return current;\r\n    }\r\n\r\n    insert(val) {\r\n        this.root = this.insertHelper(this.root, val);\r\n        this.setKey(val);\r\n        this.size += 1;\r\n        this.calculateTreeHeight();\r\n    }\r\n\r\n    insertHelper(node, val) {\r\n        if (node === null) return new Node(val);\r\n\r\n        if (val < node.value) node.left = this.insertHelper(node.left, val);\r\n        else if (val > node.value) node.right = this.insertHelper(node.right, val);\r\n\r\n        return node;\r\n    }\r\n\r\n    delete(val) {\r\n        let node  = this.getNode(val);\r\n        if (node.val > node.parent) node.parent.right = null;\r\n        else node.parent.left = null;\r\n        node.parent = null;\r\n    }\r\n\r\n    setKey(val) {\r\n        let current = this.root;\r\n        let binaryArray = [1];\r\n        while (current) {\r\n            if (val === current.value) {\r\n                break;\r\n            }\r\n            if (val > current.value) {\r\n                current = current.right;\r\n                binaryArray.push(1);\r\n            } else {\r\n                current = current.left;\r\n                binaryArray.push(0);\r\n            }\r\n        }\r\n        const binaryString = binaryArray.join(\"\");\r\n        current.key = parseInt(binaryString, 2);\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}